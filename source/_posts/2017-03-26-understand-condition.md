title: 理解条件等待Condition
date: 2017-03-26 17:17:07
categories: Java并发演进之路
tags: [Condition,条件,阻塞,唤醒]
---
<img src="/img/understand.png" width="300" class="img-topic" />
Condtion也被称为条件队列（condition queues）或者条件变量（condition variables）是利用线程间共享的全局变量进行同步的一种机制。主要包括两个动作：一个线程等待“条件谓词成立”而挂起；另一个线程使“条件谓词成立”，发出条件成立信号。由于对共享状态信息的访问发生在多线程中，因此条件变量的使用是需要结合锁机制的（一般是互斥锁）。也就是说，一个线程要等到临界区的共享数据达到某种状态时再进行某种操作，而这个状态的成立，则是由另外一个线程来完成后发送信号来通知的。
<!--more-->

本文从条件等待的标准形式说开来，解释Condition相关的术语，等待队列图从直观的角度理解条件等待，最后会对比内置监视器队列和条件队列的异同点。主要包括以下内容：
- 从条件等待的标准形式说开来
- 专业术语
- 等待队列图
- 条件等待机制 VS 轮询和休眠方式
- Object VS ConditionObject
- ConditionObject使用场景

## 从条件等待的标准形式说开来

```java
获取锁;//①
while (条件状态不满足) {//②
    释放锁;//③
    线程挂起等待，直到条件满足通知;//④
    重新获取锁;//⑤
}

操作临界区保护的共享数据;//⑥
释放锁;//⑦
```

以上是条件等待的标准形式，逐条解释一下：
①判断条件状态是否满足和操作共享数据必须在锁的保护下，保证多线程环境中同一时刻只能有一个线程修改条件状态和共享数据
②③④当条件状态不满足时，由于第1步中已经获取了，必须首先释放锁，进入等待唤醒，当前线程阻塞在④，其他线程才有机会获取锁后，修改条件状态，再唤醒等待线程。
⑤当前线程被唤醒后，需要首先获取锁，然后再次检查条件状态是否满足（原因见下文），如果再次检查发现条件状态仍然不满足（当前线程一定在想我一定遇到了一个假唤醒），那么当前线程继续重复②③④的逻辑
⑥如果当前线程备唤醒后再次检查条件状态已经满足（肯定是其他线程修改了条件状态，因为当前线程一直在等待，没有任何操作）。由于已经获得了锁，有了修改共享数据的资格。
⑦共享数据修改完后要释放掉锁，其他线程就可以尝试获取锁。就像买完火车票后就要离开售票窗口，这样后面排队的人才可以买票。

### 使用while而不使用if的原因
1. 线程可能在不满足条件状态下被唤醒，这种称为虚唤醒。在这种情况下，被唤醒的线程必须重新检查条件，否则会出现在不满足条件状态下操作共享数据，这很危险。
2. 使用notifyAll唤醒其他等待线程时，线程被唤醒到重新获取锁的间隔，其他线程已经获取锁并修改了条件状态，使得条件状态不满足。

## 专业术语
条件谓词，一个不知所云的概念。条件谓词是决定线程是等待还是执行的关键，所有等待的线程需要等待某种条件成真时才能执行，这种条件就是条件谓词。举个例子，水池有两个水管一个进水管一个出水管，当水池不满的时候，应当打开进水口，当水池满的时候应该关闭进水口。这里水池不满就是进水的条件谓词，反过来，水池不空就是打开出水的条件谓词。

